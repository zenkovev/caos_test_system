# 12-3: Python: Pydbg

## Условие задачи

Реализуйте отладчик для интерпретатора Python. Необходимо реализовать программу, которая принимает
не менее двух аргументов: имя файла с командами отладчика, затем имя файла c Python-программой, а
оставшиеся аргументы могут быть обработаны из Python-программы.

Отладчик должен поддерживать команды:
- next - выполнить одну строку, не заходя внутрь функций;
- step - выполнить одну строку, в том числе с заходом внутрь функций;
- continue - выполнить программу до конца;
- print EXPRESSION - вывести на стандартный поток выпода значение глобальной, локальной переменной
в текущем фрейме выполнения, либо выражения в синтаксисе Python с их использованием. Для
форматирования вывода использовать Python-функцию repr.

Точек останова не предусмотрено. В начальный момент выполнения файла, интерпретатор находится в
режиме паузы, то есть для выполнения первой строки программы необходима команда next или continue.

Пример использования:
```
# команды отладчика
next
next
print (a+b)*2
continue

# исходный текст на Python
a = 123         # next           -- появилась переменная a
b = 456         # next           -- появилась переменная b
                # print (a+b)*2  -- будет выведено 1158 из отладчика
c = a + b       # continue       -- появилась переменная c
print(c)        #                -- будет выведено 579 из программы
```

Указание: используйте функцию PyEval\_SetTrace.

## Комментарий к тестам

_Для форматирования вывода использовать Python-функцию repr._ <br />
До сих пор не понимаю, зачем необходимо это замечание.

В тестах присутствует только уровень `run.sh`.

Компиляция файла с программой производится с помощью `cmake`,
для этого в директории с задачей есть `CMakeLists.txt`.
Отчёт о сборке выводится в файл `tmp_files/cmake_and_make_output.txt`.
Если программа скомпилирована успешно, то она находится как `tmp_files/pydbg-bin`.

В `CMakeLists.txt` программа собирается с версией языка `Python` 3.8,
специально для этой задачи в докер-контейнер дополнительно установлена эта "старая" версия.
Это связано с тем, что известное мне решение данной задачи использует доступ к полям
объекта `PyFrameObject`, который был ограничен в последних версиях `Python`.
[Подробнее.](https://docs.python.org/3/c-api/frame.html)

## Краткое описание работы тестов

При тестировании компилируется программа.
Для этого с помощью `CMakeLists.txt` производится сборка в `tmp_files/build`,
после чего собранная программа выносится как `tmp_files/pydbg-bin`.
Если программа не собрана, то запуски программы не производятся.

Затем производятся запуски программы на пяти входах, которые представляют собой
пару из файла c Python-программой и файла с командами отладчика.
Все они находятся в директории `test_files/test_debug`.

Входы для программы:
- `test_1_example.py` и `test_1_commands.txt`:
Реализация примера из условия
- `test_2_args.py` и `test_2_commands.txt`:
Проверяет передачу аргументов Python-программе
- `test_3_functions.py` и `test_3_commands.txt`:
Этот тест построчно исполняет программу и с помощью `print` в отладчике и в самой программе
проверяет, что отладчик находится в правильной строке.
Для понимания этого теста создан вспомогательный файл `test_1_description.txt`,
который находится в той же директории `test_files/test_debug`.
Это файл `test_1_commands.txt`, в который добавлено описание того, в какой строке программы
отладчик должен находиться при исполнении текущей команды отладки
- `test_4_order.py` и `test_4_commands.txt`:
Построчная отладка программы без функций с помощью `next` и `step`,
в каждой строке программы преобразуется одна и та же переменная
- `test_5_continue.py` и `test_5_commands.txt`:
Единственная команда отладчика - `continue`
